import { RefundController } from '../refundController';
import { ClaimController } from '../claimController';
import pool from '../../config/database';
import { TreasuryService } from '../../services/treasuryService';

// Mock dependencies
jest.mock('../../config/database');
jest.mock('../../services/treasuryService');

describe('Double-Claim Exploit Prevention', () => {
  let mockClient: any;
  let mockRequest: any;
  let mockResponse: any;

  beforeEach(() => {
    jest.clearAllMocks();

    // Mock database client with transaction support
    mockClient = {
      query: jest.fn(),
      release: jest.fn(),
    };

    (pool as any).connect = jest.fn().mockResolvedValue(mockClient);
    (pool as any).query = jest.fn();

    // Mock request and response
    mockRequest = {
      userId: 'user-123',
      body: {},
    };

    mockResponse = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
  });

  describe('Winner attempting refund (completed match)', () => {
    it('should block refund claim for winner of completed match', async () => {
      mockRequest.body = {
        paymentReference: 'ref-123',
      };

      // Mock payment linked to completed match with winner
      mockClient.query
        .mockResolvedValueOnce({ rows: [] }) // BEGIN
        .mockResolvedValueOnce({
          rows: [{
            payment_reference: 'ref-123',
            user_id: 'user-123',
            match_id: 'match-123',
            amount: 10,
            normalized_status: 'confirmed',
            refund_status: 'none',
          }],
        })
        .mockResolvedValueOnce({
          // Match result - completed with winner
          rows: [{
            match_id: 'match-123',
            status: 'completed',
            result_type: 'normal',
            cancelled: false,
            winner_id: 'user-123', // User is the winner
          }],
        });

      await RefundController.claimDeposit(mockRequest as any, mockResponse as any);

      // Should rollback and block refund
      expect(mockClient.query).toHaveBeenCalledWith('ROLLBACK');
      expect(mockResponse.status).toHaveBeenCalledWith(400);
      expect(mockResponse.json).toHaveBeenCalledWith(
        expect.objectContaining({
          error: 'Cannot claim refund for this match',
          message: expect.stringContaining('Refunds are only available for cancelled or draw matches'),
        })
      );
    });

    it('should block refund claim for loser of completed match', async () => {
      mockRequest.body = {
        paymentReference: 'ref-456',
      };

      // Mock payment linked to completed match (user is loser)
      mockClient.query
        .mockResolvedValueOnce({ rows: [] }) // BEGIN
        .mockResolvedValueOnce({
          rows: [{
            payment_reference: 'ref-456',
            user_id: 'user-123',
            match_id: 'match-456',
            amount: 10,
            normalized_status: 'confirmed',
            refund_status: 'none',
          }],
        })
        .mockResolvedValueOnce({
          // Match result - completed with different winner
          rows: [{
            match_id: 'match-456',
            status: 'completed',
            result_type: 'normal',
            cancelled: false,
            winner_id: 'user-999', // Different user won
          }],
        });

      await RefundController.claimDeposit(mockRequest as any, mockResponse as any);

      // Should rollback and block refund
      expect(mockClient.query).toHaveBeenCalledWith('ROLLBACK');
      expect(mockResponse.status).toHaveBeenCalledWith(400);
      expect(mockResponse.json).toHaveBeenCalledWith(
        expect.objectContaining({
          error: 'Cannot claim refund for this match',
        })
      );
    });
  });

  describe('In-progress match refund attempts', () => {
    it('should block refund for in-progress match', async () => {
      mockRequest.body = {
        paymentReference: 'ref-789',
      };

      // Mock payment linked to in-progress match
      mockClient.query
        .mockResolvedValueOnce({ rows: [] }) // BEGIN
        .mockResolvedValueOnce({
          rows: [{
            payment_reference: 'ref-789',
            user_id: 'user-123',
            match_id: 'match-789',
            amount: 10,
            normalized_status: 'confirmed',
            refund_status: 'none',
          }],
        })
        .mockResolvedValueOnce({
          // Match result - in progress
          rows: [{
            match_id: 'match-789',
            status: 'in_progress',
            result_type: null,
            cancelled: false,
            winner_id: null,
          }],
        });

      await RefundController.claimDeposit(mockRequest as any, mockResponse as any);

      // Should rollback and block refund
      expect(mockClient.query).toHaveBeenCalledWith('ROLLBACK');
      expect(mockResponse.status).toHaveBeenCalledWith(400);
    });
  });

  describe('Draw/cancelled match refund (allowed)', () => {
    it('should allow refund for draw match (tie)', async () => {
      mockRequest.body = {
        paymentReference: 'ref-draw',
      };

      const mockTxHash = '0xabcd1234';
      (TreasuryService.sendPayout as jest.Mock).mockResolvedValue(mockTxHash);

      // Mock payment linked to draw match
      mockClient.query
        .mockResolvedValueOnce({ rows: [] }) // BEGIN
        .mockResolvedValueOnce({
          rows: [{
            payment_reference: 'ref-draw',
            user_id: 'user-123',
            match_id: 'match-draw',
            amount: 10,
            normalized_status: 'confirmed',
            refund_status: 'none',
          }],
        })
        .mockResolvedValueOnce({
          // Match result - draw/tie
          rows: [{
            match_id: 'match-draw',
            status: 'completed',
            result_type: 'tie',
            cancelled: false,
            winner_id: null,
          }],
        })
        .mockResolvedValueOnce({ rows: [] }) // UPDATE processing
        .mockResolvedValueOnce({
          rows: [{ wallet_address: '0xabcd' }],
        }) // Get user wallet
        .mockResolvedValueOnce({ rows: [] }) // UPDATE completed
        .mockResolvedValueOnce({ rows: [] }); // COMMIT

      await RefundController.claimDeposit(mockRequest as any, mockResponse as any);

      // Should allow refund
      expect(mockClient.query).toHaveBeenCalledWith('COMMIT');
      expect(mockResponse.json).toHaveBeenCalledWith(
        expect.objectContaining({
          success: true,
          transactionHash: mockTxHash,
        })
      );
    });

    it('should allow refund for cancelled match', async () => {
      mockRequest.body = {
        paymentReference: 'ref-cancelled',
      };

      const mockTxHash = '0xabcd5678';
      (TreasuryService.sendPayout as jest.Mock).mockResolvedValue(mockTxHash);

      // Mock payment linked to cancelled match
      mockClient.query
        .mockResolvedValueOnce({ rows: [] }) // BEGIN
        .mockResolvedValueOnce({
          rows: [{
            payment_reference: 'ref-cancelled',
            user_id: 'user-123',
            match_id: 'match-cancelled',
            amount: 10,
            normalized_status: 'confirmed',
            refund_status: 'none',
          }],
        })
        .mockResolvedValueOnce({
          // Match result - cancelled
          rows: [{
            match_id: 'match-cancelled',
            status: 'cancelled',
            result_type: null,
            cancelled: true,
            winner_id: null,
          }],
        })
        .mockResolvedValueOnce({ rows: [] }) // UPDATE processing
        .mockResolvedValueOnce({
          rows: [{ wallet_address: '0xabcd' }],
        }) // Get user wallet
        .mockResolvedValueOnce({ rows: [] }) // UPDATE completed
        .mockResolvedValueOnce({ rows: [] }); // COMMIT

      await RefundController.claimDeposit(mockRequest as any, mockResponse as any);

      // Should allow refund
      expect(mockClient.query).toHaveBeenCalledWith('COMMIT');
      expect(mockResponse.json).toHaveBeenCalledWith(
        expect.objectContaining({
          success: true,
          transactionHash: mockTxHash,
        })
      );
    });
  });

  describe('Orphaned deposit refund (no match)', () => {
    it('should allow refund for orphaned deposit (no match_id)', async () => {
      mockRequest.body = {
        paymentReference: 'ref-orphan',
      };

      const mockTxHash = '0xorphan123';
      (TreasuryService.sendPayout as jest.Mock).mockResolvedValue(mockTxHash);

      // Mock orphaned payment (no match_id)
      mockClient.query
        .mockResolvedValueOnce({ rows: [] }) // BEGIN
        .mockResolvedValueOnce({
          rows: [{
            payment_reference: 'ref-orphan',
            user_id: 'user-123',
            match_id: null, // No match
            amount: 10,
            normalized_status: 'confirmed',
            refund_status: 'none',
          }],
        })
        .mockResolvedValueOnce({ rows: [] }) // UPDATE processing
        .mockResolvedValueOnce({
          rows: [{ wallet_address: '0xabcd' }],
        }) // Get user wallet
        .mockResolvedValueOnce({ rows: [] }) // UPDATE completed
        .mockResolvedValueOnce({ rows: [] }); // COMMIT

      await RefundController.claimDeposit(mockRequest as any, mockResponse as any);

      // Should allow refund
      expect(mockClient.query).toHaveBeenCalledWith('COMMIT');
      expect(mockResponse.json).toHaveBeenCalledWith(
        expect.objectContaining({
          success: true,
          transactionHash: mockTxHash,
        })
      );
    });

    it('should prevent duplicate orphaned deposit refund', async () => {
      mockRequest.body = {
        paymentReference: 'ref-orphan-dup',
      };

      // Mock orphaned payment already refunded
      mockClient.query
        .mockResolvedValueOnce({ rows: [] }) // BEGIN
        .mockResolvedValueOnce({
          rows: [{
            payment_reference: 'ref-orphan-dup',
            user_id: 'user-123',
            match_id: null,
            amount: 10,
            normalized_status: 'confirmed',
            refund_status: 'completed', // Already refunded
          }],
        });

      await RefundController.claimDeposit(mockRequest as any, mockResponse as any);

      // Should block duplicate refund
      expect(mockClient.query).toHaveBeenCalledWith('ROLLBACK');
      expect(mockResponse.status).toHaveBeenCalledWith(400);
      expect(mockResponse.json).toHaveBeenCalledWith(
        expect.objectContaining({
          error: 'Already refunded',
          alreadyClaimed: true,
        })
      );
    });
  });

  describe('Winner claim duplicate prevention', () => {
    it('should prevent duplicate winner claim', async () => {
      mockRequest.body = {
        matchId: 'match-claim-123',
      };

      // Mock user data
      (pool as any).query
        .mockResolvedValueOnce({
          rows: [{ wallet_address: '0xwinner123' }],
        })
        .mockResolvedValueOnce({
          // Existing claim record (after rollback)
          rows: [{
            claim_transaction_hash: '0xexisting-tx',
            tx_hash: '0xexisting-tx',
          }],
        });

      // Mock match already claimed
      mockClient.query
        .mockResolvedValueOnce({ rows: [] }) // BEGIN
        .mockResolvedValueOnce({
          // Match data - already claimed
          rows: [{
            match_id: 'match-claim-123',
            player1_id: 'user-123',
            player2_id: 'user-456',
            status: 'completed',
            winner_id: 'user-123',
            winner_wallet: '0xwinner123',
            player1_wallet: '0xwinner123',
            player2_wallet: '0xloser456',
            player1_match_result: 'WIN',
            player2_match_result: 'LOSS',
            player1_payout_state: 'PAID', // Already paid
            player2_payout_state: 'NOT_PAID',
            claim_status: 'claimed', // Already claimed
            stake: 100000000000000000, // 0.1 WLD in wei
          }],
        })
        .mockResolvedValueOnce({ rows: [] }); // ROLLBACK

      await ClaimController.claimWinnings(mockRequest as any, mockResponse as any);

      // Should rollback and reject duplicate claim
      expect(mockClient.query).toHaveBeenCalledWith('ROLLBACK');
      expect(mockResponse.status).toHaveBeenCalledWith(400);
      expect(mockResponse.json).toHaveBeenCalledWith(
        expect.objectContaining({
          error: 'Winnings already claimed',
          alreadyClaimed: true,
          txHash: '0xexisting-tx',
        })
      );
    });
  });
});
